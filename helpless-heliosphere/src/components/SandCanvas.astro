<canvas id="sandCanvas"></canvas>

<style>
  #sandCanvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 2000;
  }
</style>

<script>
class SandParticle {
  constructor(x, y, color = 'rgba(120, 138, 255, 0.2)') {
    this.x = x;
    this.y = y;
    this.color = color;
    this.size = Math.random() * 3 + 2; // Particle size (more variation)
    this.vx = (Math.random() - 0.5) * 4; // Horizontal speed (more spread)
    this.vy = 0; // Vertical speed
    this.settled = false;
    this.friction = 0.99; // Friction that slows particles down
  }

  // Apply gravity to particle
  applyGravity() {
    this.vy += 0.15; // Gravity strength
  }

  // Apply friction to horizontal motion
  applyFriction() {
    this.vx *= this.friction; // Slow down horizontal velocity over time
  }

  // Simulate bouncing
  bounceOffWalls(canvasWidth, canvasHeight) {
    if (this.x - this.size < 0 || this.x + this.size > canvasWidth) {
      this.vx *= -0.7; // Bouncing off walls with reduced speed
    }
    if (this.y + this.size > canvasHeight) {
      this.vy *= -0.7; // Bouncing off the ground
      this.y = canvasHeight - this.size;
    }
  }

  // Check if particle is colliding with another particle
  checkCollision(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const minDist = this.size + other.size;

    if (distance < minDist) {
      // Collide and resolve overlap
      const angle = Math.atan2(dy, dx);
      const overlap = minDist - distance;
      this.x += Math.cos(angle) * overlap / 2;
      this.y += Math.sin(angle) * overlap / 2;
      other.x -= Math.cos(angle) * overlap / 2;
      other.y -= Math.sin(angle) * overlap / 2;

      // Apply simple frictional response after collision
      const normalX = Math.cos(angle);
      const normalY = Math.sin(angle);
      const relativeVelocityX = this.vx - other.vx;
      const relativeVelocityY = this.vy - other.vy;

      // Reduce velocities based on collision
      const normalVelocity = relativeVelocityX * normalX + relativeVelocityY * normalY;
      if (normalVelocity < 0) {
        const friction = 0.8;
        this.vx -= normalVelocity * friction * normalX;
        this.vy -= normalVelocity * friction * normalY;
        other.vx += normalVelocity * friction * normalX;
        other.vy += normalVelocity * friction * normalY;
      }
    }
  }
}

class SandSimulation {
  constructor() {
    this.canvas = document.getElementById('sandCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.particles = [];
    this.scrollX = window.scrollX;
    this.scrollY = window.scrollY;
    
    this.resize();
    window.addEventListener('resize', () => this.resize());
    window.addEventListener('scroll', () => this.updateScrollOffset());

    this.setupEventListeners();
    this.animate();
  }

  resize() {
    this.canvas.width = document.documentElement.scrollWidth;
    this.canvas.height = document.documentElement.scrollHeight;
  }

  updateScrollOffset() {
    this.scrollX = window.scrollX;
    this.scrollY = window.scrollY;
  }

  setupEventListeners() {
    document.addEventListener('click', (e) => {
      for (let i = 0; i < 30; i++) {
        this.particles.push(new SandParticle(e.pageX, e.pageY));
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (Math.random() < 0.5) {
        this.particles.push(new SandParticle(e.pageX, e.pageY));
      }
    });
  }

  updateParticle(particle) {
    if (particle.settled) return;

    // Apply gravity
    particle.applyGravity();

    // Update position
    particle.x += particle.vx;
    particle.y += particle.vy;

    // Apply friction to the particle to slow it down over time
    particle.applyFriction();

    // Collision detection with other particles
    this.particles.forEach(otherParticle => {
      if (particle !== otherParticle) {
        particle.checkCollision(otherParticle);
      }
    });

    // Collision with the edges (walls and floor)
    particle.bounceOffWalls(this.canvas.width, this.canvas.height);

    // Check if particle is settled (on the ground or stacked)
    if (particle.y + particle.size >= this.canvas.height) {
      particle.settled = true;
    }
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw all particles
    this.particles.forEach(particle => {
      this.ctx.fillStyle = particle.color;
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      this.ctx.fill();
    });
  }

  animate = () => {
    // Update all particles
    this.particles.forEach(particle => this.updateParticle(particle));



    this.draw();
    requestAnimationFrame(this.animate);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  new SandSimulation();
});
</script>
